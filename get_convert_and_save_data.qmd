---
format:
  html:
    toc: true
    toc-depth: 4
    page-layout: full
---

# Get, convert, and save data

## Setup

```{r}
#| label: setup

source(here::here("libraries.R"))

hhdr <- here::here("data-raw")
neon <- fs::path(hhdr, "neon")
judy <- fs::path(hhdr, "judy")
rds <- fs::path(hhdr, "rds")
work <- fs::path(hhdr, "work")

```

## Define variable mapping -- RUN THIS MANUALLY!! -- ONETIME

Map my variable names to neon names so that I have consistent names across files.

### Iteratively improve variable name mapping

This is an iterative process: 

-   get a starter set of neon names and my variable names in my xlsx metadata files in the neon folder
-   read a report exported as csv from neon, in the neon folder
-   find any neon names in the report that aren't in the starter set of neon names
-   create variable names using simple rules:
      - lower case
      - remove certain characters (e.g., "?.-")
      - remove certain character sets (e.g., "(c)" and "(f)")
      - remove space after "phone " and "line " so that "phone 2" becomes "phone2", etc.
      - trim white space at ends
      - replace / and space with _
-   repeat

```{r}
#| label: variable-mapping-function

vmap <- function(neon) {
  # neon is an input vector of neon names
  # vname is a vector of my variable names, mapped to neon
  neon |>
    str_to_lower() |>
    str_remove_all("\\?") |>
    str_remove_all("\\.") |>
    str_remove_all("-") |>
    str_remove_all("\\(c\\)|\\(f\\)") |>
    # Remove space after 'phone' and 'line' if followed by a number
    str_replace_all("phone (?=\\d)", "phone") |>
    str_replace_all("line ", "line") |>
    # Replace slashes and any surrounding whitespace with a single underscore
    str_replace_all("\\s*/\\s*", "_") |>
    # Replace any run of whitespace with a single underscore
    str_replace_all("\\s+", "_") |>
    # Trim any leading/trailing underscores that might appear
    str_replace_all("^_+|_+$", "")
}

```


```{r}
#| label: get-preliminary-mapped-vnames
#| eval: false

# To get started from scratch, get my early attempt to create metadata -- a .xlsx file:
# fpath <- fs::path(neon, "boyd_neon_metadata.xlsx")
# vnames <- readxl::read_excel(
#   fpath,
#   sheet = "variable_lookups",
#   range = cell_cols("A:D"),
#   col_types = "text"
# )

# saveRDS(vnames, fs::path(work, "prelim_variable_lookup.rds"))

# if prelim_variable_lookup.rds exists, start with it and extend it
vnames <- readRDS(fs::path(work, "prelim_variable_lookup.rds"))

# if we have neon names but not yet my local names, run vmap on the neon names:
# vnames <- vnames |>
#   mutate(vname = vmap(neon))
# saveRDS(vnames, fs::path(work, "prelim_variable_lookup.rds"))

glimpse(vnames)
vnames$neon
vnames$vname
anyDuplicated(vnames$vname)
anyDuplicated(vnames$neon)
# vmap(vnames$neon)
neon_names <- c(vnames$neon)

# which if any variable names have we duplicated?
# vnames |>
#   group_by(vname) |>
#   filter(n() > 1) |>
#   ungroup()

# vnames <- readRDS(fs::path(rds, "variable_lookup.rds"))
# lookup <- deframe(vnames[, c("vname", "neon")])
# lookup
# sort(lookup)

```

Now get report exports and other csv files from Neon. Save to the work folder, map variable names, and update work/prelim_variable_lookup.rds.

```{r}
#| label: read-new-neon-output
#| eval: false

# look for variables that are not in vnames so we can add them
fname <- "export (4).csv"
fpath <- fs::path(work, fname)

newdf <- vroom(
  fpath,
  col_types = cols(.default = col_character())
)

setdiff(names(newdf), neon_names) # what neon variables are in the new file that aren't in the

base <- tibble(neon = setdiff(names(newdf), neon_names))

newvars <- base |>
  filter(!str_starts(neon, fixed("..."))) |>
  mutate(vname = vmap(neon)) |>
  select(vname, neon)
newvars

vnames

updated_lookup <- bind_rows(vnames, newvars) |>
  arrange(neon, vname)

saveRDS(updated_lookup, fs::path(work, "prelim_variable_lookup.rds"))

# writexl::write_xlsx(
#   vnames,
#   fs::path(work, "vnames.xlsx")
# )

```

### Get the current iteratively improved lookup file and save in the rds folder

When all done updating the preliminary lookup file (work/prelim_variable_lookup.rds), get it from work/ and save it to rds/ without the "prelim" suffix.

```{r}
#| label: write-lookup-to-rds

lookup <- readRDS(fs::path(work, "prelim_variable_lookup.rds"))
# examine lookup
saveRDS(lookup, fs::path(rds, "variable_lookup.rds"))

```

## Get latest lookup information and create a lookup vector

```{r}
#| label: get-lookup

variable_lookup <- readRDS(fs::path(rds, "variable_lookup.rds"))

lookup <- deframe(variable_lookup[, c("vname", "neon")])
lookup


```

## Household contact information

From Neon: "Household Report - Don's Household contact information report"

```{r}

contactfname <- "household_contact_info_from_report_2025-07-22.csv"
contactpath <- fs::path(neon, contactfname)

contacts1 <- vroom(
  contactpath,
  col_types = cols(.default = col_character())
)
ns(contacts1)
skimr::skim(contacts1)
glimpse(contacts1)
# cbind(1:ncol(acct1), names(acct1))
# nrows <- acct1 |> distinct() |> nrow()

contacts2 <- contacts1 |>
  rename(any_of(lookup)) |>
  select(-starts_with("..."))
ns(contacts2)
skim(contacts2)

contacts3 <- contacts2 |>
  mutate(
    id = ifelse(is.na(household_id), accountid, household_id),
    name = hh_acct_name,
    group = case_when(
      !is.na(household_id) ~ "household",
      !is.na(accountid) ~ "account",
      .default = "other"
    )
  ) |>
  relocate(id, name, group)
skim(contacts3)
count(contacts3, group)
saveRDS(contacts3, fs::path(rds, "contacts.rds"))


```



## Accounts data

Get data from neon:

-   "Don's all-accounts report" -- an All Accounts Report
-   Run separately for individuals and companies and combine

```{r}
#| label: accounts-data-from-neon-report

acctfnames <- c(
  "accounts_individuals_2025-07-18.csv",
  "accounts_companies_2025-07-18.csv"
)
acctpaths <- fs::path(neon, acctfnames)

acct1 <- vroom(
  acctpaths,
  col_types = cols(.default = col_character()),
  id = "fname"
)
ns(acct1)
skimr::skim(acct1)
glimpse(acct1)
# cbind(1:ncol(acct1), names(acct1))
# nrows <- acct1 |> distinct() |> nrow()

acct2 <- acct1 |>
  rename(any_of(lookup))

glimpse(acct2)
skim(acct2) # drop ...24, activity_contactid, activityid, gender
count(acct2, importid) # drop its only values are 10 and 4 with most missing
count(acct2, do_not_contact)
count(acct2, deceased)

drops <- c(
  "...24",
  "account_type2",
  "activity_contactid",
  "activityid",
  "fname",
  "gender",
  "importid"
)

acct3 <- acct2 |>
  select(-any_of(drops)) |>
  mutate(
    reg_all_amount = parse_number(reg_all_amount),
    donation_all_amount = parse_number(donation_all_amount),
    do_not_contact = do_not_contact == "Yes",
    deceased = deceased == "Yes"
  ) |>
  mutate(
    id = ifelse(is.na(household_id), accountid, household_id),
    name = ifelse(is.na(hh_name), full_name, hh_name),
    group = case_when(
      !is.na(household_id) ~ "household",
      !is.na(accountid) ~ "account",
      .default = "other"
    )
  ) |>
  relocate(id, name, group)
ns(acct3)
glimpse(acct3)
skim(acct3)

count(acct3, account_type)
#   account_type     n
#   <chr>        <int>
# 1 Company        291
# 2 Individual    4511

saveRDS(acct3, fs::path(rds, "accounts.rds"))

```

## Create household-account linkages file for individuals in accounts data

This linkage file only includes people with accounts. "Additional contacts" who do not have accounts (e.g., a child who attends classes) are not included in this file.

TODO: Consider including information from "Don's all-contacts report", an Additional Contact Report; run on 2025-07-18.

```{r}
#| label: create-accounts

accounts <- readRDS(fs::path(rds, "accounts.rds"))
ns(accounts)

linkages <- accounts |>
  filter(account_type == "Individual") |>
  select(
    household_id,
    hh_name,
    accountid,
    full_name,
    full_address,
    city,
    state
  ) |>
  arrange(as.integer(household_id), as.integer(accountid))

saveRDS(linkages, fs::path(rds, "linkages.rds"))

```

## Donations data from donation details report

Donations from neon -- "Don's donation details report". We run the report once for Individuals and once for Companies because there does not seem to be a way to run it as a single report (?). Thus, we read the two separate reports and combine below.

-   includes most ids but not household id. However, it has household name. We need to match this against a linkage file to get
-   includes deceased and do not contact
-   Donations can include Donations, Pledges, Pledge Payments, and Matching Pledges

Oddly, the donations details report include household name but it does not appear possible to also include household id. This prepare donations in two steps (1) get the donations data without household id, and (2) add household id from the linkages file.

```{r}
#| label: donations-from-neon-report

dfnames <- c(
  "donations_detail_individuals_2025-07-21.csv",
  "donations_detail_companies_2025-07-21.csv"
)

dpaths <- fs::path(neon, dfnames)

don1 <- vroom(
  dpaths,
  col_types = cols(.default = col_character()),
  id = "fname"
)
ns(don1)
skimr::skim(don1)
glimpse(don1)

nrows <- don1 |> distinct() |> nrow()

don2 <- don1 |>
  rename(any_of(lookup))
ns(don2)
glimpse(don2)
count(don2, fname, account_type)

don3 <- don2 |>
  select(-c(starts_with("..."), fname)) |>
  mutate(
    donation_date = mdy(donation_date),
    donation = parse_number(donation),
    deceased = deceased == "Yes",
    do_not_contact = do_not_contact == "Yes"
  )
# the fields that cause problems in parse_number are shown as NA in the source data, so ok

glimpse(don3)
skim(don3)
check <- don3 |> filter(is.na(donation)) # payment_status is DEFERRED
count(check, payment_status)
count(don3, payment_status)
count(don3, donation_status)

saveRDS(don3, fs::path(rds, "donations_no_hhid.rds"))

```

## Add household IDs to donations data

Add household_id from the linkages data

```{r}
#| label: donations-with-household_id

donations_no_household_id <- readRDS(fs::path(
  rds,
  "donations_no_household_id.rds"
))
linkages <- readRDS(fs::path(rds, "linkages.rds"))

glimpse(donations_no_household_id)
ns(donations_no_household_id)
ns(linkages)

donations <- donations_no_household_id |>
  left_join(
    linkages |> select(hh_name, household_id, accountid),
    by = join_by(hh_name, accountid)
  ) |>
  mutate(
    id = ifelse(is.na(household_id), accountid, household_id),
    name = ifelse(is.na(hh_name), full_name, hh_name),
    group = case_when(
      !is.na(household_id) ~ "household",
      !is.na(accountid) ~ "account",
      .default = "other"
    )
  ) |>
  select(
    id,
    name,
    group,
    household_id,
    hh_name,
    accountid,
    full_name,
    everything()
  )

glimpse(donations)
count(donations, group)
count(donations, donation_type)
ns(donations)

saveRDS(donations, fs::path(rds, "donations.rds"))

```

## Events description data

"Events" is a neon catchall name that includes performances, classes, workshops, dinners and several other categories. Neon has an events file that can be downloaded with information on each event, including a category (performance, ...). I don't know yet how the categories are created or assigned, but I imagine Judy and possibly Erin do this.

Neon does not appear to have reports that let us extract information about events so it looks like the thing to do is export the events table.

Get and save events "as-is". Then add a major category field.

```{r}
#| label: events-description-data

efname <- "events_2025-07-20.csv"
epath <- fs::path(neon, efname)

ev1 <- vroom(epath, col_types = cols(.default = col_character()))
skimr::skim(ev1)
glimpse(ev1)
ns(ev1)

ev2 <- ev1 |>
  rename(any_of(lookup)) |>
  rename(
    event_status = status,
    event_start_date = start_date,
    event_end_date = end_date
  )
names(ev2)
glimpse(ev2)
count(ev2, event_topic) # has names of people for some events -- KEEP
count(ev2, event_code) # don't know what it is, but not blank, appears to be a date -- KEEP
count(ev2, event_attendees) # should be integer
count(ev2, event_waitlisted) # "0" for all -- DROP
count(ev2, event_start_date) # mm/dd/yyyy
count(ev2, event_end_date) # mm/dd/yyyy
count(ev2, event_status) # ACTIVE or INACTIVE -- KEEP
skim(ev2)

ev3 <- ev2 |>
  select(-c(...11, event_waitlisted)) |>
  mutate(
    event_attendees = as.integer(event_attendees),
    event_start_date = lubridate::mdy(event_start_date),
    event_end_date = lubridate::mdy(event_end_date)
  )
glimpse(ev3)
skim(ev3)
ev3 |> filter(event_attendees == 406)
count(ev3, event_category) # 43 categories; NA has 15 records

saveRDS(ev3, fs::path(rds, "events_no_majorcat.rds"))

```

## Construct and add major category for events

```{r}
#| label: events-majorcat

evcat1 <- readRDS(fs::path(rds, "events_no_majorcat.rds"))
count(evcat1, event_category)

# major category: performance, classes, ?
# minor category: music_mfs, music_other

evcat2 <- evcat1 |>
  mutate(
    event_majorcat = case_when(
      str_detect(event_category, "Performances") ~ "performance",
      event_category %in% c("Shakespeare") ~ "performance",
      event_name %in%
        c(
          "2nd Annual Hubbard Hall-oween Celebration (2016)",
          "An Unforgettable Crooner Cabaret",
          "Hubbard Hall-oween Celebration",
          "Hubbard Hall-O-Ween Monster Mash Ball; 7pm",
          "Hubbard Halloween Ball - Saturday, October 26th, 2019 at 6pm",
          "Miscast Cabaret -- Fundraiser",
          "Music From Salem Listening Club: Music About Nature",
          "Night of Duets Cabaret -- Fundraiser",
          "Songs for Scholarships Cabaret - Saturday July 28th at 7pm",
          "Special Event: A Day at the Opera, August 15",
          "TriBeCaStan: In Concert!",
          "Whispering Bones"
        ) ~
        "performance",
      str_detect(event_name, "Blues") & str_detect(event_name, "Brews") ~
        "performance", # some oddball text
      str_detect(event_name, "Christmas Carol") &
        str_detect(event_name, "Performance") ~
        "performance",

      event_category %in%
        c(
          "Classes",
          "Ballet",
          "Bollywood & BollyX",
          "Dance Workshops",
          "Foil Fencing",
          "Hip Hop",
          "Irish Step Dance",
          "Pilates/Yoga",
          "Puppetry",
          "Tap Dance",
          "Visual Arts",
          "Visual Arts - Crafts",
          "Wellness",
          "Workshops"
        ) ~
        "class",
      # event_category == "Children's Theater" &
      #   str_detect(event_name, "Performance") &
      #   !str_detect(event_name, "Performance Explorers") ~
      #   "class",
      # event_category == "Children's Theater" &
      #   str_detect(event_name, "Showcase") ~
      #   "class",
      # event_category == "Children's Theater" &
      #   str_detect(event_name, "SOLD OUT") ~
      #   "class",
      str_detect(event_category, "Classes") ~ "class", # Only needed if catching partial matches
      event_category == "Children's Theater" ~ "class",
      event_category == "Chorale" ~ "class", # CAUTION: some might be performances
      str_detect(event_category, "Martial Arts") ~ "class",
      str_detect(event_category, "Workshops") ~ "class",
      event_name %in%
        c(
          "Chair Yoga (Ages 16 & up) Fridays, Feb. 9 - May 10 -  12:15pm - 1pm"
        ) ~
        "class",

      event_category %in%
        c(
          "Community Events",
          "Curiosity Forum",
          "Dinners",
          "Exhibits, Films & Lectures",
          "Film Screenings",
          "Home & Garden",
          "Literary"
        ) ~
        "community",
      str_detect(event_name, "Community") ~ "community",
      str_detect(event_name, "Garden Tour") ~ "community",
      str_detect(event_name, "Holiday Breakfast") ~ "community",

      # note that this should come last and only pick up items not captured above
      event_category %in%
        c("Auditions", "Fundraising Events", "Special Events", NA_character_) ~
        "other",
      str_detect(event_name, "Gala") ~ "other",
      .default = "ERROR"
    )
  )

count(evcat2, event_majorcat)
tmp <- count(evcat2, event_majorcat, event_category, event_name)

# mutate(event_majorcat = case_when(
#   str_detect(event_category, "Music from Salem Performances") ~ "mfs",
#   str_detect(event_category, )
#   .default = "other"
# )

count(evcat2, event_majorcat)
saveRDS(evcat2, fs::path(rds, "events.rds"))

```

## Event registrations data

Currently this comes from exporting Events Registrations data. Done for 2 time periods separately because of neon limits on \# of records that can be exported -- 2011 through 2019 calendar years, and 2020 forward.

As with data describing events, it does not look possible to create reports for event registrations - the thing to do is export the data and then enhance it as needed.

CAUTION: the registrations data has many people in it with account names, as reported by neon, who do not have account ids. One reason is tthat they may be family members attending a performance who do not have accounts.

```{r}
#| label: registrations-from-export

regfnames <- c(
  "registrations_2011_through_2019.csv",
  "registrations_2020_through_2025-07-17.csv"
)
regpaths <- fs::path(neon, regfnames)

regs1 <- vroom(
  regpaths,
  col_types = cols(.default = col_character())
)
skimr::skim(regs1)
glimpse(regs1)

# check <- regs1 |> distinct() |> nrow()
# nrow(regs1)
# check

tmp <- regs1 |>
  group_by_all() |>
  filter(n() > 1) |>
  ungroup()
# ~ 7k duplicates, not obvious why, need to investigate -- some are without account ids and may be legitimate
# KEEP DUPLICATES FOR NOW

regs2 <- regs1 |>
  rename(any_of(lookup)) |>
  rename(
    event_status = status,
    event_start_date = start_date
  )
names(regs2)
glimpse(regs2)
skimr::skim(regs2)

regs3 <- regs2 |>
  select(-...17) |>
  mutate(
    across(contains("date"), \(x) lubridate::mdy(x)),
    amount = parse_number(amount)
  )

skimr::skim(regs3)
glimpse(regs3)

count(regs3, event_name, sort = TRUE) # 1.9k events none missing!
count(regs3, notes) # ~ 41 notes, rest are NA
count(regs3, payment_method) # 137 varieties
count(regs3, type)
# 1 Attendee              27953
# 2 Registrant             7154
# 3 Registrant & Attendee 18912
count(regs3, campaign) # 33 campaigns noted; 37k recs are NA
count(regs3, type)

events <- count(regs3, event_name, sort = TRUE) # 1.9k events none missing!

saveRDS(regs3, fs::path(rds, "registrations_no_eventid.rds"))

```


## Put eventid, event_code, event_majorcat, ..., household_id, and hh_name on registrations file

```{r}
#| label: eventid-on-registrations

events <- readRDS(fs::path(rds, "events.rds"))
linkages <- readRDS(fs::path(rds, "linkages.rds"))
regsnoid <- readRDS(fs::path(rds, "registrations_no_eventid.rds"))

ns(events)
ns(regsnoid)

regsid <- regsnoid |>
  left_join(
    events |>
      select(
        eventid,
        event_name,
        event_start_date,
        event_code,
        event_majorcat,
        event_category
      ), # event_code is a unique identifier
    by = join_by(event_name, event_start_date)
  ) |> # including event_start_date in join is crucial and needed to ensure unique matches
  left_join(
    linkages |>
      select(accountid, account_name = full_name, household_id, hh_name),
    by = join_by(accountid, account_name)
  ) |>
  mutate(
    id = ifelse(is.na(household_id), accountid, household_id),
    name = ifelse(is.na(hh_name), account_name, hh_name),
    group = case_when(
      !is.na(household_id) ~ "household",
      !is.na(accountid) ~ "account",
      .default = "other"
    )
  ) |>
  select(
    id,
    name,
    group,
    household_id,
    hh_name,
    accountid,
    account_name,
    eventid,
    event_code,
    event_name,
    event_majorcat,
    event_category,
    everything()
  )
skim(regsid)
count(regsid, type)
count(regsid, event_majorcat)
check <- regsid |> filter(is.na(event_majorcat))
sum(check$amount) # $32,531 of events that aren't in the events file
unique(check$event_name) # the missing ones all have 2025 registraions after the data import!
count(regsid, type)

saveRDS(regsid, fs::path(rds, "registrations.rds"))

# regs |>
#   filter(str_detect(type, "Registrant"), event_status == "SUCCEEDED") |>
#   summarise(n = n(), amount = sum(amount), .by = c(type, event_status)) |>
#   janitor::adorn_totals()

```


### Investigate missing data

```{r}
#| eval: false

check <- readRDS(fs::path(rds, "registrations_no_eventid.rds"))
skim(check)

# amounts by calendar year
check |>
  mutate(year = year(event_start_date)) |>
  summarise(n = n(), amount = sum(amount), .by = year) |>
  janitor::adorn_totals()

check |>
  filter(!is.na(accountid)) |>
  arrange(desc(last_mod_date)) |>
  filter(row_number() <= 24672) |>
  mutate(year = year(event_start_date)) |>
  arrange(year) |>
  summarise(n = n(), amount = sum(amount), .by = year) |>
  janitor::adorn_totals()


# amounts with and without missing names
check |>
  mutate(acctname_missing = is.na(account_name)) |>
  summarise(amount = sum(amount), .by = acctname_missing) |>
  mutate(pct = amount / sum(amount))

check |>
  mutate(accountid_missing = is.na(accountid)) |>
  summarise(n = n(), amount = sum(amount), .by = accountid_missing) |>
  mutate(pctamount = amount / sum(amount))

check |>
  # arrange(desc(last_mod_date)) |>
  # arrange(desc(event_start_date)) |>
  arrange(desc(created_date)) |>
  filter(row_number() <= 24672) |>
  mutate(has_accountid = !is.na(accountid)) |>
  summarise(n = n(), amount = sum(amount), .by = has_accountid) |>
  janitor::adorn_totals()

check |>
  arrange(desc(last_mod_date)) |>
  filter(row_number() <= 24672) |>
  mutate(has_accountid = !is.na(accountid)) |>
  summarise(n = n(), amount = sum(amount), .by = has_accountid) |>
  janitor::adorn_totals() |>
  mutate(
    pctn = n / n[has_accountid == "Total"],
    pctamount = amount / amount[has_accountid == "Total"]
  )

check |>
  arrange(desc(last_mod_date)) |>
  mutate(has_accountid = !is.na(accountid)) |>
  summarise(n = n(), amount = sum(amount), .by = has_accountid) |>
  janitor::adorn_totals() |>
  mutate(
    pctn = n / n[has_accountid == "Total"],
    pctamount = amount / amount[has_accountid == "Total"]
  )

check |>
  filter(!is.na(accountid)) |>
  arrange(desc(created_date)) |>
  filter(row_number() <= 24672) |>
  summarise(n = n(), amount = sum(amount))

```

